# Cute Gatekeeper (CTF)

A tiny two-stage web CTF built for easy hosting:
- Frontend: Next.js app (deploy to Vercel)
- Backend: Node + Express (deploy to Koyeb)

Final test flag for the challenge (do NOT hardcode or serve this directly):

```
FLAG{cutepart_fluff}
```

The app never returns the full flag in code. Players must collect:
- PART_A = `cutepart` (shown on dashboard)
- PART_B = `fluff` (fetched from backend with a header check)

## Repository Layout

```
/frontend   # Next.js app with /login and /dashboard
/backend    # Express server exposing GET /get_part_b
```

## Stage Overview

- Stage 1 (client-only): `/login` shows an obvious JS constant `const correct = "hunter2";`. When correct, it stores `localStorage.logged = "1"` and routes to `/dashboard`.
- Stage 2 (dashboard): Contains `const clientToken = "tok123";` and helper `makeHeader(t){ return btoa(t + "|pepper") }` (also exposed on `window`). Clicking "Get PART_B" calls the backend endpoint `/get_part_b` with header `X-Client-Token: makeHeader(clientToken)`. The backend compares against an environment variable and returns `{ part_b: "fluff" }` on success.

## Environment Variables

- Backend
  - `EXPECTED_CLIENT_TOKEN` (required): should be the base64 value the server expects. For the default flow, set it to base64 of `tok123|pepper`, which is `dG9rMTIzfHBlcHBlcg==`.
  - `PORT` (optional, default `4000`)
- Frontend
  - `NEXT_PUBLIC_BACKEND_URL` (only for production): full backend URL, e.g. `https://YOUR-KOYEB-APP.koyeb.app`. For local dev, the frontend proxies to `http://localhost:4000` automatically via Next.js rewrites.

## Local Development

Requirements: Node 18+ (Node 20 recommended)

1) Install dependencies

```bash
# In /frontend
cd frontend
npm install

# In /backend
cd ../backend
npm install
```

2) Configure backend env

```bash
# In /backend
# Set EXPECTED_CLIENT_TOKEN to base64("tok123|pepper") for the default puzzle
set EXPECTED_CLIENT_TOKEN=dG9rMTIzfHBlcHBlcg==
# PowerShell users can use: $env:EXPECTED_CLIENT_TOKEN = "dG9rMTIzfHBlcHBlcg=="
```

3) Run both apps

```bash
# Terminal A
cd backend
npm run dev
# backend on http://localhost:4000

# Terminal B
cd frontend
npm run dev
# frontend on http://localhost:3000
```

4) Try it locally
- Visit `http://localhost:3000/login`
- Password: `hunter2`
- On dashboard, click "Get PART_B" → expect `PART_B = fluff` from backend

## Deployment

### Backend → Koyeb

- Dockerfile is provided in `/backend`.
- Build & deploy with Koyeb:
  1. Create a new Koyeb service from Git or Dockerfile pointing to `/backend`.
  2. Set environment variable `EXPECTED_CLIENT_TOKEN = dG9rMTIzfHBlcHBlcg==`.
  3. Expose port `4000` (default CMD runs `node server.js`).
  4. After deploy, note the public URL like `https://cute-gatekeeper-xxxx.koyeb.app`.

### Frontend → Vercel

- In Vercel project settings:
  1. Set `NEXT_PUBLIC_BACKEND_URL = https://cute-gatekeeper-xxxx.koyeb.app` (your backend URL).
  2. Deploy the `/frontend` directory as a Next.js app.
  3. No serverless functions are used; all calls go to the Koyeb backend.

## Security Notes

- This CTF is intentionally simple. No complex crypto, no file I/O, no code exec.
- The final assembled flag never appears in any API response or source string; only `PART_A` and `PART_B` appear separately.

## Files of Interest

- Frontend
  - `src/pages/login.tsx` — client-only login with `const correct = "hunter2";`
  - `src/pages/dashboard.tsx` — shows PART_A and fetches PART_B using `X-Client-Token`
  - `next.config.js` — local dev rewrites `/get_part_b` → `http://localhost:4000/get_part_b`
- Backend
  - `server.js` — Express server with `GET /get_part_b`
  - `Dockerfile` — container for Koyeb deployment

## 3-step verification checklist

1) Local: backend `GET /get_part_b` returns `{ part_b: "fluff" }` when header `X-Client-Token: dG9rMTIzfHBlcHBlcg==` is sent, otherwise 403; frontend dashboard successfully fetches PART_B.
2) Deploy: Vercel site’s dashboard calls Koyeb backend and receives `part_b: "fluff"`.
3) Assemble: Combine PART_A (`cutepart`) and PART_B (`fluff`) to verify the final flag `FLAG{cutepart_fluff}`.
